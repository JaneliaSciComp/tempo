function [pulseInfo, pulseInfo2, pcndInfo] = PulseSegmentation(xsong, xempty, pps, a, b, c, d, e, f, g, h, i, j, k, l, Fs)
%SUMMARY:
% Analyzes the song clip xsong and based on where putativepulse2 identifies
% putative pulse trains, extracts individual pulses within these clips
% using wavelet transformation. This is done by computing the continuous wavelet transform
% of the song clip for the derivative of guassian (DoG) wavelet family,
% which represent pulses, to those computed for the morlet wavelet,
% representing sines, and flags events as pulses dependent on if the DoG coefficient was higher. A detailed
% description follows below.
% 
% RETURNS:
% The structures pulseInfo, pulseInfo2, pcndInfo, and sineseg. The first
% three provide information about the extracted pulse clips, and the last
% provides information about the sine clips. pcndInfo and pulseInfo contain
% information about
% candidate pulses, while pulseInfo2 contains information about the
% subset of the candidate pulses that were classified as true
% pulses. The fields of these structures contain information for
% each of the pulse clips extracted, e.g. the average energy of the
% 50'th true pulse is pulseInfo2.aven(50). In particular, the 50'th
% true pulse itself can be seen by plotting pulseInfo2.x{50}. Note
% that the 'x' field is a cell array since different pulses will
% have different lengths. The fields of pcndInfo and pulseInfo are listed below:
%
% x:    The clip itself.
% dog: The derivative-of-gaussian wavelet that best matched this
%      pulse. E.g. if pulseInfo2.dog(10)=2, then the 10'th true pulse 
%      was best matched by a 2nd derivative of gaussian.
%
% fcmx: The frequency of the best matched wavelet. This is related in 
%       a roughly inverse manner to the best matched scale.
%
% scmx: The scale of the best matched wavelet.
% i0:   The starting time bin of the pulse clip.
% i1:   The ending time bin of the pulse clip.
% wc:   The time bin at which the highest correlation occured.
% w0:   The starting bin of a window around wc.
% w1:   The ending bin of a window around wc.
%
% The distinction between [i0,i1] and [w0 w1] is that [i0 i1] is the local 
% section whose CWT coefficients for the DoG wavelets exceeded its 
% coefficients for the morlet wavelets. Although the extent of the pulse
% overlaps considerably with [i0 i1], it's not necessarily centered on
% it. Instead, we find the location of the maximum coefficient within 
% [i0 i1], which we call wc, and define the pulse to be some window [w0 w1]
% around this location. 
%
% pulseInfo2 contains the additional fields 
%
% clipped: = 1 if this clip was cut off by the data start or end points.
% mxv:  The maximum absolute value of the voltage achieved during the clip.
% aven: The average energy of the clip.
%
% pcndInfo contains the additional fields
%
% comment: The string 'OK' if the clip was accepted, or a short explanation 
%          of why the clip was rejected.
% length:  The length of the clip = i1-i0+1.
%
%
% PulseSegmentation requires the Wavelet Toolbox and the Signal Processing Toolbox.
%
% DETAILED DESCRIPTION: 
% This script attempts to segment putative pulse trains into individual
% pulses. Its data requirements are the flysong clip (xsong) and the
% structure pps, which contains the start and stop times and the clips
% themselves for the putative pulse trains.
%
% The idea behind pulse segmentation is quite simple: we flag an event as
% pulse if it looks more like a pulse than a sine!
% This is done in several steps.
%
% 1) A typical pulse looks very similar to the Derivative of
% Gaussian a.k.a. the 'mexican hat' wavelet. A whole family of
% such funcations can be generated by repeatedly taking
% derivatives, and the first few members of this family look very
% similar to observed Drosophila melanogaster courtship song pulses (other species pulses may be better fit by different wavelets and wavelet families). 
% We use these as our canonical pulse
% shapes. We then use the Continuous Wavelet Transform (cwt) to
% correlate the song clip (from pps) with each of these canonical pulse
% shapes. For each DoG wavelet, we perform the CWT over a range of
% 'scales'. 'Scale' can be roughly thought of as the inverse of
% frequency, and sweeping over scale values in effect correlates
% the song clip with stretched and compressed versions of each
% pulse shape. This allows us to test a broad range of possible
% pulse shapes.
%
% We then repeat the same procedure with the morlet wavelet (sinusoid with
% a guassian enevelope) over the same range of scales. 
%
% 2) Step 1 gives us CWT coefficients for each pulse shape and
% each scale. In Step 2, we pool the
% coefficients across the different pulse shapes to find
% the best-matched shape and scale at each point in time i.e. this
% will allow us to say that at 2.3 seconds into the clip, the best
% matched pulse shape was a second order mexican-hat at a frequency
% of 200 Hz. We do the same thing for the Morlet (sine) wavelet as
% well. So at the end of this step, instead of having coefficients
% for each pulse shape and sine shape and for each different scale,
% we have one set of coefficients representing the best matched
% pulse shapes, and one set of coefficients representing the best
% matched sine shapes. Comparing these two allows us to see which
% fits better.
%
% 3) Due to the sinusoidal nature of pulses and sines, the results
% of step 2 will be sinusoidal. Hence in this step we find the
% peaks of the coefficients and use interp1 to interpolate between
% them to compute the envelopes.
%
% 4) At the start of this step we have two envelopes: one for the
% pulse shaped wavelets and one for the sine shaped wavelets. We
% then simply compare them and flag the regions in which the pulse
% shaped wavelets are larger as 'candidate pulse clips'.
%
% 6) We then 'winnow' the the candidate pulses based on the criteria described below. The pulses that make it through
% this winnowing procedure are the 'true' pulses, and saved in pulseInfo2.
%
%========PARAMETERS=================
segParams.fc = a; % frequencies examined. These will be
                  % converted to CWT scales later on.

segParams.fs = b; % sample rate (in Hz)

segParams.DoGwvlt = c;  % Derivative of Gaussian wavelets examined

segParams.minCmhPkDistance = d; % Minimum distance for mexican hat
                                % wavelet peaks to be considered separate.
                                % (if two pulse peaks are this close
                                % together, they are merged and considered
                                % to be just one event)

segParams.minCmoPkDistance = e; %Minimum distance for morelet
                                 %wavelet peaks to be considered separate.

segParams.pulsewindow = f; %factor for computing window around pulse peak (this determines how much of the signal before and after the peak is included in the pulse.)

xn = xempty;
noise = g*mean(abs(xn));                         
segParams.wnwMinAbsVoltage = noise; %Minimum Absolute Value of the Voltage = g times the mean

segParams.wnwPkpkWnd = h;      % Width of the window in samples to
                                 % measure peak-to-peak voltage

segParams.IPI = i; %in samples, if no other pulse within this many samples, do not count as a pulse (the idea is that a single pulse (not within IPI range of another pulse) is likely not a true pulse)

segParams.tiny = j; %if pulse peak height is more than j times smaller than the pulse peaks on either side (within 100ms), don't include

segParams.frequency = k; %if pulseInfo.fcmx is greater than this frequency, then don't include pulse

segParams.close = l; %if pulse peaks are this close together, only keep the larger pulse

segParams.pnpc_th = 99;     % Power percentile at and above which a
                            % clip is marked as signal rather than noise.
                            

sp = segParams;

%% Load the Signals

xs = xsong; %right now not downsampling - still at 10KHz
xs  = xs(:);
xn = xempty;

%% Prepare for CWT
ngw = numel(sp.DoGwvlt);
fc  = sp.fc;
fs  = sp.fs;

wvlt = cell(1,ngw+1);
wvlt{1} = 'morl';
%#function morlet

for i = 1:ngw
    wvlt{i+1} = ['gaus' num2str(sp.DoGwvlt(i))];
end
%#function gauswavf

sc = zeros(ngw+1,numel(fc));

for i = 1:numel(wvlt)
    sc(i,:) = scales_for_freqs(fc,1/fs,wvlt{i});
end

%% Perform CWT on Signal

cmo = zeros(1,numel(xs)); % Storage for the maximum morlet wavelet
                          % coefficient for each bin.

cmh = cmo;                % Storage for the maximum mexican hat
                          % wavelet coefficient for each bin.

cmo_sc = cmo;             % Storage for the scale at which the
                          % highest coefficient occured for each bin.

cmh_dog = cmo;            % Storage for the order of the
                          % D.o.G. wavelet for which the highest
                          % coefficient occured.

cmh_sc = cmo;             % Storage for the scale at which the
                          % highest mexican hat coefficient occured.
for i= 1:numel(wvlt)
    Cs = cwt(xs,sc(i,:),wvlt{i});
    % Compute power
    Ps = Cs.*conj(Cs);
    
    % Find the maximum coefficient for each bin.
    [cs,ci] = max(abs(Cs));    
    if (isequal(wvlt{i},'morl'))
        cmo = cs;
        cmo_sc = ci;
    else
        cmh1 = cs;
        best_sc = ci;
        cmh1gtcmh = cmh1>cmh; % indices where current coefficient
                              % was greater than the running max.

        % Update the max scale for each bin.
        cmh_sc = cmh1gtcmh.*best_sc + ~cmh1gtcmh.*cmh_sc; 
        
        % Update the max coefficient for each bin.
        cmh = cmh1.*cmh1gtcmh+cmh.*~cmh1gtcmh; 
        
        % Update the max DoG order for each bin.
        cmh_dog = (i-1).*cmh1gtcmh+cmh_dog.*~cmh1gtcmh; 
        
    end
end


%% Use output of putativepulse2 (pps) to identify regions of song that may contain pulses
%  Compute sine (morlet) and pulse (DoG) envelopes and Extract cmh>cmo clips 

for i=1:numel(pps.start);
    a = xsong(round(pps.start(i)*Fs):round(pps.stop(i)*Fs));
    b = size(a,1);
    pps.stop2(1,i) = round(pps.start(i)*Fs) + round(b) - 1;
end
putpul = struct('i0',round(pps.start*Fs), 'i1', pps.stop2);
number = numel(pps.start);

A = [];
A = length(cmh);
B=[];
B = length(double(putpul.i1));
if putpul.i0(1) < 1;
    putpul.i0(1) = 1;
end
if putpul.i1(B) > A;
    putpul.i1(B) = A;
end

pulses = {};
pulse_start_times = [];
pulse_lengths = [];

n = 1;
for i=1:number;
    if double(putpul.i0(i)) == double(putpul.i1(i));
        continue
    end    
    mex_signal = cmh(putpul.i0(i):putpul.i1(i)); 
    mor_signal = cmo(putpul.i0(i):putpul.i1(i));
    if length(mex_signal) < 50;
        continue
    end
    [pk_cmh,pk_cmh_i] = findpeaks(mex_signal,'minpeakdistance',sp.minCmhPkDistance);
    [pk_cmo,pk_cmo_i] = findpeaks(mor_signal,'minpeakdistance',sp.minCmoPkDistance); 
    v_cmh = interp1(pk_cmh_i,pk_cmh,1:numel(mex_signal),'spline','extrap');
    v_cmo = interp1(pk_cmo_i,pk_cmo,1:numel(mor_signal),'spline','extrap');
    index = (v_cmh > v_cmo);
    [rcnd,l,s] = extract_runs(xs(putpul.i0(i):putpul.i1(i)),double(index));
    pulses(n:n+length(s)-1) = rcnd;
    pulse_start_times(n:n+length(s)-1) = double(s)+putpul.i0(i)-1;
    pulse_lengths(n:n+length(s)-1) = double(l);
    n = n + length(s);
end

zz = zeros(1,length(pulse_start_times));
pulse_stop_times = pulse_start_times+pulse_lengths-1;
pcndInfo = struct('i0',double(pulse_start_times),'i1', double(pulse_stop_times), 'length',double(pulse_lengths),...
           'ok',zz,...
           'dog',zz,'scmx',zz,'fcmx',zz,'w0',zz,'w1',zz,'wc',zz);


%% Winnow pulses
indPulse = 0*xs;
np = numel(pulses);
npad = 10000;

xsp = [zeros(npad,1);xs;zeros(npad,1)];
nOk = 0;

% Two structures are used to store information about the winnowing
% process. pcndInfo contains information about all pulse
% candidates. If a pulse makes it past the winnowing process, its
% information is stored in pulseInfo. If not, the 'comment' field
% of the pcndInfo structure will indicate why not.
pcndInfo.comment = cell(1,np);
zz = zeros(1,np);
pulseInfo.dog = zz; % the DoG order at max
pulseInfo.fcmx = zz;
pulseInfo.wc = zz; % location of peak correlation
pulseInfo.w0 = zz; % start of window centered at wc
pulseInfo.w1 = zz; % end of window centered at wc
pulseInfo.i0 = zz; % start of pulse clip
pulseInfo.i1 = zz; % end of pulse clip
pulseInfo.clipped = zz; % was this section clipped at the beginning
                        % or end?
pulseInfo.x = cell(1,np); % the signals themselves
pulseInfo.mxv = zz;
pulseInfo.aven = zz;
for i = 1:np
   pcndInfo.comment{i}='OK';
   
   % find the location of the correlation peak and set the pulse window
   cc = cmh(pcndInfo.i0(i):pcndInfo.i1(i));
   iccmax = find(cc==max(cc),1)-1+pcndInfo.i0(i);
   dog_at_max = cmh_dog(iccmax);
   sc_at_max = sc(dog_at_max+1,cmh_sc(iccmax));
   fc_at_max = fc(cmh_sc(iccmax));
   pcndInfo.dog(i) = dog_at_max;
   pcndInfo.fcmx(i) = fc_at_max;
   pcndInfo.scmx(i) = sc_at_max;
   pcndInfo.wc(i) = iccmax;
   m = sp.pulsewindow;
   pcndInfo.w0(i) = round(iccmax-m*sc_at_max); 
   if pcndInfo.w0(i) < 0;
       pcndInfo.w0(i) = 1;
   end
   pcndInfo.w1(i) = round(iccmax+m*sc_at_max); 
   if pcndInfo.w1(i) > length(xs);
       pcndInfo.w1(i) = length(xs);
   end
   
   %fprintf('\t\tBest-matched wavelet: gaus%d.\n',dog_at_max);
   %fprintf('\t\tBest-matched scale:   % 2.1f.\n',sc_at_max);
   %fprintf('\t\tEquivalent frequency: % 3.1f.\n',fc_at_max);
   
   %=======Don't include very small pulses (below the noise threshold define by g*mean(xempty))==========:
   i0 = pcndInfo.i0(i);
   i1 = pcndInfo.i1(i);
   y = max(abs(xs(i0:i1)));
   if (y<sp.wnwMinAbsVoltage)
       pcndInfo.comment{i} = 'tlav';    
       continue;
   end
   
   indPulse(max(pcndInfo.w0(i),1):min(pcndInfo.w1(i),numel(xs)))=1;
   pcndInfo.ok(i) = 1;
   nOk = nOk+1;
   
   pulseInfo.dog(nOk) = pcndInfo.dog(i);
   pulseInfo.fcmx(nOk) = pcndInfo.fcmx(i);
   pulseInfo.scmx(nOk) = pcndInfo.scmx(i);
   pulseInfo.wc(nOk) = pcndInfo.wc(i);
   pulseInfo.w0(nOk) = pcndInfo.w0(i);
   pulseInfo.w1(nOk) = pcndInfo.w1(i);   
   pulseInfo.i0(nOk) = pcndInfo.i0(i);
   pulseInfo.i1(nOk) = pcndInfo.i1(i);
   j0 = max(pulseInfo.w0(nOk),1);
   j1 = min(pulseInfo.w1(nOk),numel(xs));
   pulseInfo.x{nOk} = xs(j0:j1);
   pulseInfo.aven(nOk) = mean(xs(j0:j1).^2);
   pulseInfo.clipped(nOk) = (j0~=pulseInfo.w0(nOk) || j1~=pulseInfo.w1(nOk));
   pulseInfo.mxv(nOk) = max(abs(xs(j0:j1)));   
end

if (nOk)
  pulseInfo.dog = pulseInfo.dog(1:nOk);
  pulseInfo.fcmx = pulseInfo.fcmx(1:nOk);
  pulseInfo.scmx = pulseInfo.scmx(1:nOk);
  pulseInfo.wc = pulseInfo.wc(1:nOk);
  pulseInfo.w0 = pulseInfo.w0(1:nOk);
  pulseInfo.w1 = pulseInfo.w1(1:nOk);
  pulseInfo.i0 = pulseInfo.i0(1:nOk);
  pulseInfo.i1 = pulseInfo.i1(1:nOk);
  pulseInfo.aven = pulseInfo.aven(1:nOk);
  pulseInfo.x = pulseInfo.x(1:nOk);
  pulseInfo.clipped = pulseInfo.clipped(1:nOk);
  pulseInfo.mxv = pulseInfo.mxv(1:nOk);
end

%%
%now that you have collected pulses in pulseInfo, winnow further:
indPulse = 0*xs;
np = length(pulseInfo.x);
npad = 10000;
xsp = [zeros(npad,1);xs;zeros(npad,1)];
nOk = 0;

zz = zeros(1,np);
pulseInfo2.dog = zz; % the DoG order at max
pulseInfo2.fcmx = zz;
pulseInfo2.wc = zz; % location of peak correlation
pulseInfo2.w0 = zz; % start of window centered at wc
pulseInfo2.w1 = zz; % end of window centered at wc
pulseInfo2.i0 = zz; % start of pulse clip
pulseInfo2.i1 = zz; % end of pulse clip
pulseInfo2.clipped = zz; % was this section clipped at the beginning
                        % or end?
pulseInfo2.x = cell(1,np); % the signals themselves
pulseInfo2.mxv = zz;
pulseInfo2.aven = zz;

for i = 1:np;
    
%======Don't include pulse > certain frequency==========

if pulseInfo.fcmx(i)>sp.frequency
    continue
end

%======Don't include pulses without another pulse (either before or after) within segParams.IPI samples==========:
    a=[];
    b=[];
    c=[];
    a = pulseInfo.w0(i);
    if i < np;
        b = pulseInfo.w0(i+1);
    elseif i == np;
        b = pulseInfo.w0(i);
    end
    
    if i>1;
        c = pulseInfo.w0(i-1);
    elseif i == 1;
        c = pulseInfo.w0(i);
    end
    
    if b-a>sp.IPI && a-c>sp.IPI; 
        continue;
    end
    
%=====If pulses are close together (within 10ms), keep the larger pulse===========
    a0=[];
    a1=[];
    b0=[];
    b1=[];
    c0=[];
    c1=[];
    a0 = pulseInfo.w0(i);
    a1 = pulseInfo.w1(i);
    y = max(abs(xs(a0:a1))); %pulse peak
    if i < np;
        b0 = pulseInfo.w0(i+1);
        b1 = pulseInfo.w1(i+1);
        y1 = max(abs(xs(b0:b1))); %next pulse peak
    elseif i == np;
        b0 = a0;
        b1 = a1;
        y1 = y;
    end
    
    if i>1;
        c0 = pulseInfo.w0(i-1);
        c1 = pulseInfo.w1(i-1);
        y0 = max(abs(xs(c0:c1))); %previous pulse peak
    elseif i == 1;
        c0 = a0;
        c1 = a1;
        y0 = y;
    end
    
    if b0-a0 < sp.close && y<y1; %if the pulse is within 10ms of the pulse after it and is smaller in amplitude 
        continue;
    elseif a0-c0 < sp.close && y<y0; %if the pulse is within 10ms of the pulse before it and is smaller in amplitude
        continue;  
    end
       
    
%======If pulse peak height is more than j times smaller than the pulse peaks on either side (within 100ms), don't include========: 
    a0=[];
    a1=[];
    b0=[];
    b1=[];
    c0=[];
    c1=[];
    a0 = pulseInfo.i0(i);
    a1 = pulseInfo.i1(i);
    if i < np;
        b0 = pulseInfo.i0(i+1);
        b1 = pulseInfo.i1(i+1);
    elseif i == np;
        b0 = a0;
        b1 = a1;
    end
    
    if i>1;
        c0 = pulseInfo.i0(i-1);
        c1 = pulseInfo.i1(i-1);
    elseif i == 1;
        c0 = a0;
        c1 = a1;
    end
    
    y = max(abs(xs(a0:a1))); %pulse peak
    y0 = max(abs(xs(c0:c1))); %previous pulse peak
    y1 = max(abs(xs(b0:b1))); %next pulse peak
    
    factor = sp.tiny;
    
    if b0-a0 <= round(Fs/100) && a0-c0 <= round(Fs/100) && factor*y<y0 && factor*y<y1; %if the pulse is not within 100ms of a pulse on either side
        continue;
    end
    
   
   indPulse(max(pulseInfo.w0(i),1):min(pulseInfo.w1(i),numel(xs)))=1;
   pulseInfo2.ok(i) = 1;
   nOk = nOk+1;
   
   pulseInfo2.dog(nOk) = pulseInfo.dog(i);
   pulseInfo2.fcmx(nOk) = pulseInfo.fcmx(i);
   pulseInfo2.scmx(nOk) = pulseInfo.scmx(i);
   pulseInfo2.wc(nOk) = pulseInfo.wc(i);
   pulseInfo2.w0(nOk) = pulseInfo.w0(i);
   pulseInfo2.w1(nOk) = pulseInfo.w1(i);   
   pulseInfo2.i0(nOk) = pulseInfo.i0(i);
   pulseInfo2.i1(nOk) = pulseInfo.i1(i);
   pulseInfo2.x{nOk} = pulseInfo.x{i};
   pulseInfo2.aven(nOk) = pulseInfo.aven(i);
   pulseInfo2.clipped(nOk) = pulseInfo.clipped(i);
   pulseInfo2.mxv(nOk) = pulseInfo.mxv(i);
end

if (nOk)
  pulseInfo2.dog = pulseInfo2.dog(1:nOk);
  pulseInfo2.fcmx = pulseInfo2.fcmx(1:nOk);
  pulseInfo2.scmx = pulseInfo2.scmx(1:nOk);
  pulseInfo2.wc = pulseInfo2.wc(1:nOk);
  pulseInfo2.w0 = pulseInfo2.w0(1:nOk);
  pulseInfo2.w1 = pulseInfo2.w1(1:nOk);
  pulseInfo2.i0 = pulseInfo2.i0(1:nOk);
  pulseInfo2.i1 = pulseInfo2.i1(1:nOk);
  pulseInfo2.aven = pulseInfo2.aven(1:nOk);
  pulseInfo2.x = pulseInfo2.x(1:nOk);
  pulseInfo2.clipped = pulseInfo2.clipped(1:nOk);
  pulseInfo2.mxv = pulseInfo2.mxv(1:nOk);
end

